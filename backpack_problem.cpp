#include <iostream> // для работы ввода/вывода 
#include <cstdlib> // для работы "паузы" в консольном приложении через system
#include <ctime> // для работы генератора рандомных чисел через привязку к текущему времени
#include <vector> // для работы с векторами
#include <algorithm> // для работы сортировки вектора

int main()
{
    using namespace std;
    setlocale(LC_CTYPE, "rus"); //поправляем отображение кириллицы в консольной программе
    int number; //обьявление переменной максимального веса рюкзака
    cout << "введите ваш порядковый номер в группе" << endl; //запрос пользователю ввести номер в группе
    cin >> number; // ввод номера пользователем
    //number = 15; // указание номера пользователем для теста
    int weightBP; //обьявление переменной максимальной вместимости рюкзака
    weightBP = number + 200; //вычисление вместимости рюкзака
    //weightBP = 42; //указание максимального веса рюкзака вручную для тестов
    int kolvo; //обьявление переменной количества вещей
    kolvo = number + 30; //вычисление количества вещей
    //kolvo = 5; // указание количества вещей для укладки в рюкзак вручную для тестов
    int kolvo_temp = kolvo + 1; // введение временной переменной
    int weightBP_temp = weightBP + 1; // введение временной переменной
    srand(time(NULL)); //вносим немного разнообразия в задачу - при каждом запуске программы вес вещей будет менятся

////====================================================================================================================================
//// заполнение первичными рандомными данными вектора векторов iVector
////====================================================================================================================================
    int p_temp; // введение временной переменной
    int w_temp; // введение временной переменной

    //vector<int>weight(kolvo), cost(kolvo), pnumber(kolvo);
    vector<vector<int> > iVector(kolvo); //вводим вектор с параметрами рассматриваемых вещей
    for (int i = 0; i < kolvo; i++)
        {
            iVector[i].resize(3); //меняем размер векторов вектора iVector
            p_temp = rand() % 400 + 100; // цикл рандомно геренирует ценность каждой вещи в пределах от 100 до 500
            w_temp = rand() % 30 + 10; // цикл рандомно геренирует вес каждой вещи в пределах от 10 до 40
            iVector[i][0] = w_temp; // записываем вес каждой вещи
            iVector[i][1] = p_temp; // записываем стоимость каждой вещи
            iVector[i][2] = i; // записываем номер в первоначальном векторе (также удобен для отслеживания вектора при сортировке)
        }
////====================================================================================================================================
//// конец заполнения первичными данными вектора векторов iVector
////====================================================================================================================================

////====================================================================================================================================
//// вывод на печать информации о рассматриваемых вещах iVector
////====================================================================================================================================
        cout << "Изначальная последовательность вещей " << endl;
        for (int i = 0; i < kolvo; i++)
            {
                cout << "Вес вещи № " << i + 1 << " равен " << iVector[i][0] << ", а ценность " << iVector[i][1] << " порядковый номер вещи в изначальной последовательности " << iVector[i][2] + 1 << endl; //цикл для вывода информации о весе вещей
            }
////====================================================================================================================================
//// конец вывода на печать информации о рассматриваемых вещах iVector
////====================================================================================================================================

////====================================================================================================================================
////сортируем элементы вектора iVector по "стоимости" вар1 (по возрастанию) для удобства анализа поведения программы на малых величинах
////====================================================================================================================================

/*
    sort(iVector.begin(), iVector.end(), [](const vector<int>& a, const vector<int>& b)
        {
            return (abs(a[1]) < abs(b[1]));
        }
    );
*/
////====================================================================================================================================
////сортируем элементы вектора iVector по "стоимости" вар2 (по убыванию) для удобства анализа поведения программы на малых величинах
////====================================================================================================================================
/*
    sort(iVector.begin(), iVector.end(), [](const vector<int>& a, const vector<int>& b)
        {
            return (abs(a[1]) > abs(b[1]));
        }
    );
*/
////====================================================================================================================================
////конец сортировки
////====================================================================================================================================

////====================================================================================================================================
////вывод на печать вектора iVector после сортировки  для удобства анализа поведения программы на малых величинах
////====================================================================================================================================
/*
    cout << "==============================================================" << endl;
    cout << "==============================================================" << endl;
    cout << "Вывод на печать вектора iVector после сортировки" << endl;
    cout << "==============================================================" << endl;
    cout << "==============================================================" << endl;


    for (int i = 0; i < 3; i++)
    {
        for (int j = 0; j < iVector.size(); j++)
        {
            cout << iVector[j][i] << " ";
        }
        cout << endl;
    }


    cout << "==============================================================" << endl;
    cout << "==============================================================" << endl;
    cout << "==============================================================" << endl;
    cout << "==============================================================" << endl;
*/
////====================================================================================================================================
////конец вывода на печать вектора iVector после сортировки для удобства анализа поведения программы на малых величинах
////====================================================================================================================================



////====================================================================================================================================
////проверочный ввод данных iVector вручную для удобства анализа поведения программы на малых величинах (добавить при необходимости)
////====================================================================================================================================
    /*
    iVector[0][0] = 10;
    iVector[1][0] = 18;
    iVector[2][0] = 18;
    iVector[0][1] = 423;
    iVector[1][1] = 198;
    iVector[2][1] = 133;
    iVector[0][2] = 0;
    iVector[1][2] = 2;
    iVector[2][2] = 1;
    */
////====================================================================================================================================
////конец проверочного ввода данных iVector вручную для удобства анализа поведения программы на малых величинах
////====================================================================================================================================

////====================================================================================================================================
////вывод на печать вектора iVector после ввода данных для удобства анализа поведения программы на малых величинах
////====================================================================================================================================
/*
    cout << "==============================================================" << endl;
    cout << "==============================================================" << endl;
    cout << "Вывод на печать вектора iVector после ручного введения после сортировки" << endl;
    cout << "==============================================================" << endl;
    cout << "==============================================================" << endl;
    for (int i = 0; i < 3; i++)
    {
        for (int j = 0; j < iVector.size(); j++)
        {
            cout << iVector[j][i] << " ";
        }
        cout << endl;
    }
    cout << "==============================================================" << endl;
    cout << "==============================================================" << endl;
    cout << "==============================================================" << endl;
    cout << "==============================================================" << endl;
 */
////====================================================================================================================================
////конец вывода на печать вектора iVector после ввода данных для удобства анализа поведения программы на малых величинах
////====================================================================================================================================

////====================================================================================================================================
////====================================================================================================================================
////вводим iTemp (временная таблица промежуточных значений максимальной стоимости при меньших количествах вещей и меньших весах)
////====================================================================================================================================
////====================================================================================================================================
    vector<vector<int> > iTemp; // (временная таблица промежуточных значений максимальной стоимости при меньших количествах вещей и меньших весах)
////====================================================================================================================================
////задание размера векторов вектора iTemp
////====================================================================================================================================
    iTemp.resize(weightBP_temp);
    for (int i = 0; i < weightBP_temp; i++)
        {
            iTemp[i].resize(kolvo_temp);
        }
////====================================================================================================================================
////конец задания размера векторов вектора iTemp
////====================================================================================================================================

////====================================================================================================================================
////построение очевидных вариантов для максимального веса 0 или количества вещей 0 (НЕ НУЖНО, ВЕКТОР УЖЕ С 0) 
////включить для устранения ошибок с ручным вводом значений вектора iMassiv
////====================================================================================================================================
/*
    for (int i = 0; i < weightBP_temp; i++)
    {
        iTemp[i][0] = 0;
    }
    for (int j = 0; j < kolvo_temp; j++)
    {
        iTemp[0][j] = 0;
    }
*/
////====================================================================================================================================
////построение вычисляемых значений iTemp (временная таблица промежуточных значений максимальной стоимости при меньших количествах вещей и меньших весах)
////====================================================================================================================================
    for (int n = 1; n <= kolvo; n++)
        {
            for (int W = 1; W <= weightBP; W++)
                {
                    if (iVector[n - 1][0] <= W)
                        {
                            iTemp[W][n] = max(iVector[n - 1][1] + iTemp[W - iVector[n - 1][0]][n - 1], iTemp[W][n - 1]);
                        }
                    else
                        {
                            iTemp[W][n] = iTemp[W][n - 1];
                        }
                }
        }
////====================================================================================================================================
////====================================================================================================================================
////конец построения iTemp
////====================================================================================================================================
////====================================================================================================================================

////====================================================================================================================================
////вывод на печать вектора iTemp для удобства анализа поведения программы на малых величинах
////====================================================================================================================================
/*
    cout << "==============================================================" << endl;
    cout << "==============================================================" << endl;
    cout << "Вывод на печать вектора iTemp для удобства анализа поведения программы на малых величинах" << endl;
    cout << "==============================================================" << endl;
    cout << "==============================================================" << endl;

    if (iTemp.size())
    {
        for (int i = 0; i < iTemp[i].size(); i++)
        {
            for (int j = 0; j < iTemp.size(); j++)
            {
                cout << iTemp[j][i] << " ";
            }
            cout << endl;
        }
    }

    cout << "==============================================================" << endl;
    cout << "==============================================================" << endl;
    cout << "==============================================================" << endl;
    cout << "==============================================================" << endl;
*/
////====================================================================================================================================
////конец вывода на печать вектора iTemp для удобства анализа поведения программы на малых величинах
////====================================================================================================================================

////====================================================================================================================================
////Вычисление вещей, вошедших в мешок
////====================================================================================================================================
    int cost_win = iTemp[iTemp.size() - 1][iTemp[iTemp.size() - 1].size() - 1]; // сохранение максимального результата по стоимости (главный искомый результат)
    int cost_temp = cost_win; //введение временной переменной (используется в вычислении вещей, необходимых для получения максимального результата по стоимости)
    int weight_temp = weightBP; //введение временной переменной (используется в вычислении вещей, необходимых для получения максимального результата по стоимости)
    int weight_win = 0; // введение временной переменной (используется для вычисления веса искомых вещей с максимальной суммарной стоимостью)
    int n = kolvo; //введение временной переменной 
    vector<int>Otvet; //вводим и вычисляем побочные результаты к ответу
    while ((n > 0) && (weight_temp > 0))
        {
            if (cost_temp != iTemp[weight_temp][n - 1])
                {
                    Otvet.push_back(iVector[n - 1][2]);
                    weight_win = weight_win + iVector[n - 1][0];
                    cost_temp = cost_temp - iVector[n - 1][1];
                    weight_temp = weight_temp - iVector[n - 1][0];
                }
            n = n - 1;
        }

////====================================================================================================================================
////конец Вычисления вещей, вошедших в мешок
////====================================================================================================================================

////====================================================================================================================================
////печать отчёта с ответом по задаче
////====================================================================================================================================
    cout << "номер в группе " << number << endl; //запрос пользователю ввести номер в группе
    cout << "Для максимальной стоимости, в рюкзак следует положить вещи с номерами: " << endl;
    for (int i = 0; i < Otvet.size() - 1; i++)
        {
            cout << Otvet[i] << ", ";
        }
    cout << Otvet[Otvet.size() - 1] << ";" << endl;
    cout << "Стоимость этих вещей " << cost_win << endl;
    cout << "Вес этих вещей " << weight_win << endl;
////====================================================================================================================================
////конец печати отчёта с ответом по задаче
////====================================================================================================================================

////====================================================================================================================================
////очистка векторов векторов
////====================================================================================================================================
    iTemp.clear();
    Otvet.clear();
    iVector.clear();
////====================================================================================================================================
////конец очистки векторов векторов
////====================================================================================================================================

    system("pause"); // передача "паузы" в консоль через  MS Visual Studio
    return 0;
}












